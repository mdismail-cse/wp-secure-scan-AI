class VulnerabilityReporter
  def initialize(scan)
    @scan = scan
  end

  def generate_report
    {
      summary: generate_summary,
      risk_assessment: generate_risk_assessment,
      vulnerabilities_by_severity: group_vulnerabilities_by_severity,
      vulnerabilities_by_type: group_vulnerabilities_by_type,
      remediation_plan: generate_remediation_plan,
      wordpress_specific_analysis: generate_wordpress_analysis
    }
  end

  private

  def generate_summary
    total_vulns = @scan.vulnerabilities.count
    critical_count = @scan.vulnerabilities.where(severity: 'critical').count
    high_count = @scan.vulnerabilities.where(severity: 'high').count
    
    {
      total_vulnerabilities: total_vulns,
      critical_vulnerabilities: critical_count,
      high_vulnerabilities: high_count,
      medium_vulnerabilities: @scan.vulnerabilities.where(severity: 'medium').count,
      low_vulnerabilities: @scan.vulnerabilities.where(severity: 'low').count,
      risk_level: @scan.risk_level,
      scan_duration: @scan.duration_display
    }
  end

  def generate_risk_assessment
    critical_vulns = @scan.vulnerabilities.where(severity: 'critical')
    high_vulns = @scan.vulnerabilities.where(severity: 'high')
    
    risk_score = calculate_risk_score
    
    {
      risk_score: risk_score,
      risk_level: determine_risk_level(risk_score),
      impact_assessment: generate_impact_assessment(critical_vulns, high_vulns),
      exploitation_likelihood: assess_exploitation_likelihood,
      recommended_actions: generate_recommended_actions(risk_score)
    }
  end

  def calculate_risk_score
    # CVSS-inspired scoring
    base_score = 0
    
    @scan.vulnerabilities.each do |vuln|
      case vuln.severity
      when 'critical'
        base_score += 10
      when 'high'
        base_score += 7
      when 'medium'
        base_score += 4
      when 'low'
        base_score += 1
      end
    end
    
    # Cap at 100
    [base_score, 100].min
  end

  def determine_risk_level(score)
    case score
    when 90..100
      'Critical Risk'
    when 70..89
      'High Risk'
    when 40..69
      'Medium Risk'
    when 10..39
      'Low Risk'
    else
      'Minimal Risk'
    end
  end

  def generate_impact_assessment(critical_vulns, high_vulns)
    impacts = []
    
    if critical_vulns.any? { |v| v.vulnerability_type.include?('Remote Code Execution') }
      impacts << 'Complete server compromise possible'
    end
    
    if critical_vulns.any? { |v| v.vulnerability_type.include?('SQL Injection') }
      impacts << 'Database compromise and data theft possible'
    end
    
    if high_vulns.any? { |v| v.vulnerability_type.include?('Privilege Escalation') }
      impacts << 'Unauthorized administrative access possible'
    end
    
    if high_vulns.any? { |v| v.vulnerability_type.include?('XSS') }
      impacts << 'User account compromise through client-side attacks'
    end
    
    impacts
  end

  def assess_exploitation_likelihood
    # Check for publicly exposed vulnerabilities
    public_endpoints = @scan.vulnerabilities.select do |v|
      v.code_snippet.match?(/wp_ajax_nopriv_|register_rest_route/)
    end
    
    if public_endpoints.any?
      'High - Vulnerabilities in publicly accessible endpoints'
    elsif @scan.vulnerabilities.where(severity: 'critical').any?
      'High - Critical vulnerabilities present'
    elsif @scan.vulnerabilities.where(severity: 'high').any?
      'Medium - High severity vulnerabilities require authenticated access'
    else
      'Low - Only minor vulnerabilities detected'
    end
  end

  def generate_recommended_actions(risk_score)
    actions = []
    
    if risk_score >= 90
      actions << 'IMMEDIATE ACTION REQUIRED: Take plugin offline until critical vulnerabilities are patched'
      actions << 'Conduct emergency security audit of all affected systems'
      actions << 'Check logs for signs of exploitation'
    elsif risk_score >= 70
      actions << 'HIGH PRIORITY: Address critical and high severity vulnerabilities within 24-48 hours'
      actions << 'Implement temporary mitigations if immediate patching is not possible'
    elsif risk_score >= 40
      actions << 'Schedule remediation of vulnerabilities within the next release cycle'
      actions << 'Prioritize high severity issues'
    else
      actions << 'Address vulnerabilities in regular maintenance cycle'
      actions << 'Focus on secure coding practices to prevent future issues'
    end
    
    actions
  end

  def group_vulnerabilities_by_severity
    @scan.vulnerabilities.group_by(&:severity).transform_values do |vulns|
      vulns.map { |v| vulnerability_details(v) }
    end
  end

  def group_vulnerabilities_by_type
    @scan.vulnerabilities.group_by(&:vulnerability_type).transform_values do |vulns|
      {
        count: vulns.count,
        severity_distribution: vulns.group_by(&:severity).transform_values(&:count),
        affected_files: vulns.map(&:file_path).uniq,
        vulnerabilities: vulns.map { |v| vulnerability_details(v) }
      }
    end
  end

  def vulnerability_details(vuln)
    {
      id: vuln.id,
      type: vuln.vulnerability_type,
      severity: vuln.severity,
      file: vuln.file_path,
      line: vuln.line_number,
      code_snippet: vuln.code_snippet,
      description: vuln.description,
      remediation: generate_specific_remediation(vuln),
      poc: generate_poc_outline(vuln)
    }
  end

  def generate_specific_remediation(vuln)
    base_remediation = REMEDIATION_GUIDANCE[vuln.vulnerability_type] || {}
    
    {
      immediate_fix: base_remediation[:immediate] || 'Apply security best practices',
      code_example: base_remediation[:example] || nil,
      references: base_remediation[:references] || []
    }
  end

  def generate_poc_outline(vuln)
    case vuln.vulnerability_type
    when 'SQL Injection'
      {
        attack_vector: 'HTTP Parameter manipulation',
        payload_example: "' OR '1'='1",
        expected_result: 'Database error or data disclosure'
      }
    when /XSS/
      {
        attack_vector: 'Malicious JavaScript injection',
        payload_example: '<script>alert(document.cookie)</script>',
        expected_result: 'JavaScript execution in victim browser'
      }
    when 'Remote Code Execution'
      {
        attack_vector: 'Command injection',
        payload_example: 'system command injection',
        expected_result: 'Arbitrary command execution on server'
      }
    else
      nil
    end
  end

  def generate_remediation_plan
    plan = {
      priority_order: [],
      estimated_effort: {},
      implementation_guide: {}
    }
    
    # Group by severity and type
    by_severity = @scan.vulnerabilities.group_by(&:severity)
    
    # Priority order
    ['critical', 'high', 'medium', 'low'].each do |severity|
      if by_severity[severity]&.any?
        plan[:priority_order] << {
          severity: severity,
          count: by_severity[severity].count,
          types: by_severity[severity].map(&:vulnerability_type).uniq
        }
      end
    end
    
    # Effort estimation
    total_vulns = @scan.vulnerabilities.count
    plan[:estimated_effort] = {
      total_hours: estimate_remediation_hours(total_vulns, by_severity),
      breakdown: {
        critical: (by_severity['critical']&.count || 0) * 4,
        high: (by_severity['high']&.count || 0) * 2,
        medium: (by_severity['medium']&.count || 0) * 1,
        low: (by_severity['low']&.count || 0) * 0.5
      }
    }
    
    plan
  end

  def estimate_remediation_hours(total, by_severity)
    hours = 0
    hours += (by_severity['critical']&.count || 0) * 4
    hours += (by_severity['high']&.count || 0) * 2
    hours += (by_severity['medium']&.count || 0) * 1
    hours += (by_severity['low']&.count || 0) * 0.5
    hours
  end

  def generate_wordpress_analysis
    {
      plugin_metadata: extract_plugin_metadata,
      wordpress_hooks: analyze_wordpress_hooks,
      security_headers: check_security_headers,
      wordpress_api_usage: analyze_wp_api_usage
    }
  end

  def extract_plugin_metadata
    # This would parse the plugin header from the main file
    {
      name: @scan.plugin_name,
      version: 'Unknown',
      requires_wp: 'Unknown',
      requires_php: 'Unknown'
    }
  end

  def analyze_wordpress_hooks
    # Analyze the context data stored with vulnerabilities
    {}
  end

  def check_security_headers
    # Check for security headers in the code
    {}
  end

  def analyze_wp_api_usage
    # Analyze WordPress API usage patterns
    {}
  end

  REMEDIATION_GUIDANCE = {
    'SQL Injection' => {
      immediate: 'Use $wpdb->prepare() with placeholders for all dynamic SQL queries',
      example: '$wpdb->prepare("SELECT * FROM table WHERE id = %d", $user_input)',
      references: ['https://developer.wordpress.org/reference/classes/wpdb/prepare/']
    },
    'Stored XSS' => {
      immediate: 'Escape all output using appropriate WordPress functions',
      example: 'echo esc_html($user_input);',
      references: ['https://developer.wordpress.org/apis/security/escaping/']
    },
    'Remote Code Execution' => {
      immediate: 'Never pass user input to execution functions. Use whitelisting.',
      example: 'Use a switch statement with predefined function names instead of dynamic calls',
      references: ['https://www.php.net/manual/en/security.php']
    }
    # Add more as needed
  }.freeze
end
