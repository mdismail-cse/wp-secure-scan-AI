require 'zip'

require 'zip'

class VulnerabilityScanner
  # WordPress-specific input sources to track
  INPUT_SOURCES = [
    '$_GET', '$_POST', '$_REQUEST', '$_COOKIE', '$_SERVER', '$_FILES', '$_SESSION',
    'filter_input', 'filter_var', 'filter_input_array', 'filter_var_array',
    'get_query_var', 'get_post_meta', 'get_user_meta', 'get_option', 'get_site_option',
    'get_theme_mod', 'get_transient', 'wp_unslash', 'stripslashes_deep'
  ].freeze

  # WordPress hooks and functions to monitor
  WP_HOOKS = {
    ajax: ['wp_ajax_', 'wp_ajax_nopriv_'],
    admin: ['admin_init', 'admin_menu', 'admin_post_'],
    rest: ['register_rest_route'],
    shortcode: ['add_shortcode'],
    block: ['register_block_type'],
    filter: ['add_filter', 'apply_filters'],
    action: ['add_action', 'do_action']
  }.freeze

  # SQL Injection target functions
  SQL_FUNCTIONS = [
    '$wpdb->query', '$wpdb->get_var', '$wpdb->get_row', '$wpdb->get_col',
    '$wpdb->get_results', '$wpdb->prepare', 'esc_sql', 'like_escape'
  ].freeze

  # XSS output functions
  OUTPUT_FUNCTIONS = [
    'echo', 'print', 'printf', 'sprintf', 'vprintf', 'vsprintf',
    'print_r', 'var_dump', 'var_export', 'die', 'exit'
  ].freeze

  # Escaping functions
  ESCAPE_FUNCTIONS = [
    'esc_html', 'esc_attr', 'esc_url', 'esc_js', 'esc_textarea',
    'wp_kses', 'wp_kses_post', 'wp_kses_data', 'sanitize_text_field'
  ].freeze

  # RCE dangerous functions
  RCE_FUNCTIONS = [
    'system', 'exec', 'shell_exec', 'passthru', 'proc_open', 'eval',
    'call_user_func', 'call_user_func_array', 'create_function'
  ].freeze

  # File operation functions
  FILE_FUNCTIONS = [
    'move_uploaded_file', 'file_put_contents', 'fwrite', 'fputs', 'copy',
    'file_get_contents', 'readfile', 'fopen', 'fread', 'fgets', 'file',
    'unlink', 'rmdir', 'include', 'include_once', 'require', 'require_once'
  ].freeze

  # Access control functions
  ACCESS_FUNCTIONS = [
    'current_user_can', 'is_admin', 'is_user_logged_in', 'wp_verify_nonce',
    'check_admin_referer', 'check_ajax_referer'
  ].freeze

  # Privilege functions
  PRIVILEGE_FUNCTIONS = [
    'update_option', 'update_user_meta', 'wp_insert_user', 'wp_update_user',
    'wp_set_password', 'wp_set_auth_cookie', 'wp_set_current_user'
  ].freeze

  def initialize(scan)
    @scan = scan
    @vulnerabilities = []
    @code_context = {}
    @function_map = {}
    @hook_map = {}
    @input_flow = {}
  end

  # Main scanning method called by ScanProcessorJob
  def scan
    Rails.logger.info "Starting vulnerability scan for scan ID: #{@scan.id}"

    begin
      # Get the file path from Active Storage
      if @scan.plugin_file.attached?
        # Download the file to a temporary location
        @scan.plugin_file.open do |tempfile|
          extract_and_scan_files(tempfile.path)
        end
      else
        raise "No plugin file attached to scan"
      end

      # Update scan status
      @scan.update!(
        status: 'completed'
      )

      Rails.logger.info "Scan completed successfully for scan ID: #{@scan.id}"
    rescue => e
      Rails.logger.error "Scan failed for scan ID: #{@scan.id}: #{e.message}"
      @scan.update!(
        status: 'failed',
        scan_results: { error: e.message }
      )
    end
  end

  def scan_file(file_path, content)
    return unless content && !content.empty?

    # Phase 1: Code Mapping
    map_wordpress_hooks(content)
    map_functions(content)
    map_input_sources(content)

    # Phase 2: Vulnerability Scanning
    detect_sql_injection(file_path, content)
    detect_xss(file_path, content)
    detect_rce(file_path, content)
    detect_file_upload(file_path, content)
    detect_access_control(file_path, content)
    detect_privilege_escalation(file_path, content)
    detect_file_operations(file_path, content)
    detect_lfi(file_path, content)
    detect_object_injection(file_path, content)
    detect_csrf(file_path, content)
    detect_additional_vulnerabilities(file_path, content)
  end

  def get_line_number(content, match_text)
    lines = content.split("\n")
    lines.each_with_index do |line, index|
      return index + 1 if line.include?(match_text.to_s.split("\n").first)
    end
    1
  end

  def get_code_context(content, match_text, context_lines = 5)
    lines = content.split("\n")
    target_line_index = nil

    # Find the line containing the match
    lines.each_with_index do |line, index|
      if line.include?(match_text.to_s.split("\n").first)
        target_line_index = index
        break
      end
    end

    return match_text.strip if target_line_index.nil?

    # Calculate start and end indices for context
    start_index = [0, target_line_index - context_lines].max
    end_index = [lines.length - 1, target_line_index + context_lines].min

    # Build the context with line numbers
    context_lines_array = []
    (start_index..end_index).each do |i|
      line_number = i + 1
      prefix = i == target_line_index ? ">>> " : "    "
      context_lines_array << "#{prefix}#{line_number.to_s.rjust(4)}: #{lines[i]}"
    end

    context_lines_array.join("\n")
  end

  def add_vulnerability(vuln_data)
    @vulnerabilities << vuln_data
  end

  def vulnerabilities
    @vulnerabilities
  end

  private

  # Phase 1: Code Mapping Methods
  def map_wordpress_hooks(content)
    WP_HOOKS.each do |hook_type, patterns|
      patterns.each do |pattern|
        content.scan(/#{Regexp.escape(pattern)}['"]\s*([^'"]+)['"]/) do |match|
          hook_name = match[0]
          @hook_map[hook_name] ||= []
          @hook_map[hook_name] << { type: hook_type, pattern: pattern }
        end
      end
    end
  end

  def map_functions(content)
    # Map function definitions
    content.scan(/function\s+(\w+)\s*\([^)]*\)\s*{/) do |match|
      func_name = match[0]
      @function_map[func_name] = true
    end
  end

  def map_input_sources(content)
    INPUT_SOURCES.each do |source|
      content.scan(/#{Regexp.escape(source)}\s*\[['"]?([^'"\]]+)['"]?\]/) do |match|
        param_name = match[0]
        @input_flow[param_name] ||= []
        @input_flow[param_name] << source
      end
    end
  end

  # SQL Injection Detection
  def detect_sql_injection(file_path, content)
    # Pattern 1: Direct concatenation in queries
    content.scan(/\$wpdb->(?:query|get_var|get_row|get_col|get_results)\s*\([^)]*["'].*?\.\s*\$[^)]+\)/) do |match|
      unless match.include?('prepare')
        add_vulnerability(
          type: 'SQL Injection',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Direct concatenation of user input in SQL query without prepare statement'
        )
      end
    end

    # Pattern 2: Missing prepare on dynamic queries
    SQL_FUNCTIONS.each do |func|
      pattern = /#{Regexp.escape(func)}\s*\([^)]*\$[^)]+\)/
      content.scan(pattern) do |match|
        unless match.include?('prepare') || match.include?('esc_sql')
          add_vulnerability(
            type: 'SQL Injection',
            severity: 'critical',
            file: file_path,
            line: get_line_number(content, match),
            code: get_code_context(content, match),
            description: 'Dynamic SQL query without proper escaping'
          )
        end
      end
    end

    # Pattern 3: ORDER BY injection
    content.scan(/ORDER\s+BY\s+[^'"\s]*\$[^'"\s]+/i) do |match|
      add_vulnerability(
        type: 'SQL Injection',
        severity: 'high',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'Potential ORDER BY SQL injection - user input in ORDER BY clause'
      )
    end

    # Pattern 4: wp_unslash before queries
    content.scan(/wp_unslash\s*\([^)]+\)[^;]*\$wpdb->/) do |match|
      add_vulnerability(
        type: 'SQL Injection',
        severity: 'critical',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'wp_unslash() used before database operation - bypasses WordPress magic quotes'
      )
    end
  end

  # XSS Detection
  def detect_xss(file_path, content)
    # Stored XSS via Shortcodes
    content.scan(/add_shortcode\s*\(\s*['"]([^'"]+)['"]\s*,\s*['"]?(\w+)/) do |match|
      shortcode_name = match[0]
      callback = match[1]

      # Find the callback function
      func_pattern = /function\s+#{Regexp.escape(callback)}\s*\([^)]*\)\s*{([^}]+)}/m
      if func_match = content.match(func_pattern)
        func_body = func_match[1]

        # Check for unescaped output
        OUTPUT_FUNCTIONS.each do |output_func|
          if func_body.match(/#{output_func}\s*\([^)]*\$/) &&
             !ESCAPE_FUNCTIONS.any? { |esc| func_body.include?(esc) }
            add_vulnerability(
              type: 'Cross-Site Scripting (XSS)',
              severity: 'high',
              file: file_path,
              line: get_line_number(content, func_match[0]),
              code: get_code_context(content, func_match[0]),
              description: 'Unescaped output in shortcode callback - potential stored XSS'
            )
          end
        end
      end
    end

    # Reflected XSS via Query Args
    content.scan(/(?:add_query_arg|remove_query_arg)\s*\([^)]+\)/) do |match|
      if match.match(/echo|print/) && !match.include?('esc_url')
        add_vulnerability(
          type: 'Cross-Site Scripting (XSS)',
          severity: 'medium',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Unescaped query argument output - potential reflected XSS'
        )
      end
    end

    # Admin Notice XSS
    content.scan(/add_action\s*\(\s*['"]admin_notices['"][^}]+}/m) do |match|
      if match.match(/\$_(?:GET|POST|REQUEST)/) && !ESCAPE_FUNCTIONS.any? { |esc| match.include?(esc) }
        add_vulnerability(
          type: 'Cross-Site Scripting (XSS)',
          severity: 'medium',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Unescaped user input in admin notice - potential XSS'
        )
      end
    end

    # Gutenberg Block XSS
    content.scan(/register_block_type[^}]+render_callback[^}]+}/m) do |match|
      if match.match(/attributes/) && !ESCAPE_FUNCTIONS.any? { |esc| match.include?(esc) }
        add_vulnerability(
          type: 'Cross-Site Scripting (XSS)',
          severity: 'high',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Unescaped block attributes in render callback - potential XSS'
        )
      end
    end
  end

  # RCE Detection
  def detect_rce(file_path, content)
    RCE_FUNCTIONS.each do |func|
      # Direct user input to dangerous functions
      pattern = /#{Regexp.escape(func)}\s*\([^)]*\$_(?:GET|POST|REQUEST|COOKIE)[^)]*\)/
      content.scan(pattern) do |match|
        add_vulnerability(
          type: 'Remote Code Execution',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "Direct user input passed to #{func} - critical RCE vulnerability"
        )
      end

      # Variable functions
      content.scan(/\$\w+\s*=\s*\$_(?:GET|POST|REQUEST)[^;]+;\s*\$\w+\s*\(/) do |match|
        add_vulnerability(
          type: 'Remote Code Execution',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Dynamic function call with user input - potential RCE'
        )
      end
    end

    # call_user_func with user input
    content.scan(/call_user_func(?:_array)?\s*\([^,)]*\$_(?:GET|POST|REQUEST)/) do |match|
      add_vulnerability(
        type: 'Remote Code Execution',
        severity: 'critical',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'User input as callback in call_user_func - critical RCE'
      )
    end
  end

  # File Upload Detection
  def detect_file_upload(file_path, content)
    # Check for file upload handlers
    FILE_FUNCTIONS.each do |func|
      if func == 'move_uploaded_file'
        content.scan(/#{func}\s*\([^)]+\)/) do |match|
          # Check for file type validation
          unless match.match(/wp_check_filetype|mime_content_type|finfo/)
            add_vulnerability(
              type: 'Arbitrary File Upload',
              severity: 'critical',
              file: file_path,
              line: get_line_number(content, match),
              code: get_code_context(content, match),
              description: 'File upload without proper type validation'
            )
          end
        end
      end
    end

    # Check for wp_handle_upload with test_type => false
    content.scan(/wp_handle_upload[^)]+test_type['"]\s*=>\s*false/) do |match|
      add_vulnerability(
        type: 'Arbitrary File Upload',
        severity: 'high',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'wp_handle_upload with test_type disabled - bypasses MIME validation'
      )
    end

    # Check for ZipArchive extraction
    content.scan(/ZipArchive::extractTo\s*\([^)]+\)/) do |match|
      unless match.match(/realpath|basename/)
        add_vulnerability(
          type: 'Arbitrary File Upload',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Zip extraction without path validation - potential zip slip vulnerability'
        )
      end
    end
  end

  # Access Control Detection
  def detect_access_control(file_path, content)
    # Check AJAX handlers
    content.scan(/add_action\s*\(\s*['"]wp_ajax_nopriv_([^'"]+)['"][^}]+}/m) do |match|
      action_name = match[0]
      action_body = match.to_s

      # Check if sensitive operations without auth
      if action_body.match(/update_option|delete_option|wp_insert_|wp_update_|wp_delete_/)
        add_vulnerability(
          type: 'Broken Access Control',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match.to_s),
          code: get_code_context(content, match.to_s),
          description: 'Public AJAX endpoint performing sensitive operations'
        )
      end
    end

    # Check REST API endpoints
    content.scan(/register_rest_route[^}]+permission_callback[^}]+__return_true[^}]+}/m) do |match|
      add_vulnerability(
        type: 'Broken Access Control',
        severity: 'high',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'REST API endpoint with open permissions (__return_true)'
      )
    end

    # Check for missing nonce verification
    content.scan(/add_action\s*\(\s*['"](?:admin_post_|wp_ajax_)([^'"]+)['"]\s*,[^}]+}/m) do |match|
      action_body = match.to_s
      unless action_body.match(/wp_verify_nonce|check_admin_referer|check_ajax_referer/)
        add_vulnerability(
          type: 'Cross-Site Request Forgery (CSRF)',
          severity: 'medium',
          file: file_path,
          line: get_line_number(content, match.to_s),
          code: get_code_context(content, match.to_s),
          description: 'Action handler without nonce verification'
        )
      end
    end
  end

  # Privilege Escalation Detection
  def detect_privilege_escalation(file_path, content)
    # Check for arbitrary option updates
    content.scan(/update_option\s*\([^,)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
      add_vulnerability(
        type: 'Privilege Escalation',
        severity: 'critical',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'User-controlled option name in update_option - potential privilege escalation'
      )
    end

    # Check for user meta manipulation
    content.scan(/update_user_meta\s*\([^,)]*,[^,)]*wp_capabilities/) do |match|
      add_vulnerability(
        type: 'Privilege Escalation',
        severity: 'critical',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'Direct manipulation of wp_capabilities user meta - privilege escalation'
      )
    end

    # Check for role parameter in user functions
    content.scan(/wp_insert_user\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
      if match.include?('role')
        add_vulnerability(
          type: 'Privilege Escalation',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'User-controlled role parameter in wp_insert_user'
        )
      end
    end
  end

  # File Operations Detection
  def detect_file_operations(file_path, content)
    # Arbitrary file read
    ['file_get_contents', 'readfile', 'fopen'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
        add_vulnerability(
          type: 'Arbitrary File Read',
          severity: 'high',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "User input in #{func} - potential arbitrary file read"
        )
      end
    end

    # Arbitrary file deletion
    ['unlink', 'rmdir', 'wp_delete_file'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
        add_vulnerability(
          type: 'Arbitrary File Deletion',
          severity: 'high',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "User input in #{func} - potential arbitrary file deletion"
        )
      end
    end
  end

  # Local File Inclusion Detection
  def detect_lfi(file_path, content)
    ['include', 'include_once', 'require', 'require_once'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
        add_vulnerability(
          type: 'Local File Inclusion',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "User input in #{func} - critical LFI vulnerability"
        )
      end
    end
  end

  # PHP Object Injection Detection
  def detect_object_injection(file_path, content)
    ['unserialize', 'maybe_unserialize'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST|COOKIE)[^)]*\)/) do |match|
        add_vulnerability(
          type: 'PHP Object Injection',
          severity: 'critical',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "User input passed to #{func} - PHP object injection vulnerability"
        )
      end
    end
  end

  # CSRF Detection (already partially implemented in access control)
  def detect_csrf(file_path, content)
    # State-changing GET requests
    content.scan(/\$_GET[^}]+(?:update_option|delete_option|wp_insert_|wp_update_|wp_delete_)/) do |match|
      add_vulnerability(
        type: 'Cross-Site Request Forgery (CSRF)',
        severity: 'medium',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'State-changing operation via GET request - CSRF vulnerability'
      )
    end
  end

  # Additional Vulnerabilities Detection
  def detect_additional_vulnerabilities(file_path, content)
    # Open Redirect
    ['wp_redirect', 'header'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
        unless match.match(/wp_validate_redirect|wp_safe_redirect/)
          add_vulnerability(
            type: 'Open Redirect',
            severity: 'medium',
            file: file_path,
            line: get_line_number(content, match),
            code: get_code_context(content, match),
            description: "User input in #{func} without validation - open redirect vulnerability"
          )
        end
      end
    end

    # SSRF
    ['wp_remote_get', 'wp_remote_post', 'curl_exec'].each do |func|
      content.scan(/#{func}\s*\([^)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
        add_vulnerability(
          type: 'Server-Side Request Forgery (SSRF)',
          severity: 'high',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: "User input in #{func} - potential SSRF vulnerability"
        )
      end
    end

    # Type Juggling in authentication
    content.scan(/if\s*\([^=)]*==\s*[^=)]*\$_(?:GET|POST|REQUEST)[^)]*\)/) do |match|
      if match.match(/password|token|key|auth/)
        add_vulnerability(
          type: 'Type Juggling',
          severity: 'high',
          file: file_path,
          line: get_line_number(content, match),
          code: get_code_context(content, match),
          description: 'Loose comparison (==) in authentication - type juggling vulnerability'
        )
      end
    end

    # Information Disclosure
    content.scan(/(?:var_dump|print_r|var_export)\s*\([^)]*\$/) do |match|
      add_vulnerability(
        type: 'Information Disclosure',
        severity: 'low',
        file: file_path,
        line: get_line_number(content, match),
        code: get_code_context(content, match),
        description: 'Debug function with variable data - potential information disclosure'
      )
    end
  end

  private

  def extract_and_scan_files(zip_path)
    Zip::File.open(zip_path) do |zip_file|
      zip_file.each do |entry|
        next unless entry.file? && entry.name.end_with?('.php')

        content = entry.get_input_stream.read
        scan_file(entry.name, content)
      end
    end

    # Save vulnerabilities to database
    @vulnerabilities.each do |vuln|
      @scan.vulnerabilities.create!(
        vulnerability_type: vuln[:type],
        severity: vuln[:severity],
        file_path: vuln[:file],
        line_number: vuln[:line],
        code_snippet: vuln[:code],
        description: vuln[:description]
      )
    end
  end
end