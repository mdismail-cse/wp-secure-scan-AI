require 'test_helper'

class VulnerabilityScannerTest < ActiveSupport::TestCase
  setup do
    @user = users(:one)
    @scan = Scan.create!(
      user: @user,
      plugin_name: "Test Plugin",
      status: "pending"
    )
  end

  test "detects SQL injection vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      function get_user_data() {
        global $wpdb;
        $user_id = $_GET['user_id'];
        $query = "SELECT * FROM users WHERE id = " . $user_id;
        $results = $wpdb->query($query);
        return $results;
      }
      
      function search_posts() {
        global $wpdb;
        $search = $_POST['search'];
        $wpdb->get_results("SELECT * FROM posts WHERE title LIKE '%" . $search . "%'");
      }
      
      function delete_item() {
        global $wpdb;
        $id = $_REQUEST['id'];
        $wpdb->query("DELETE FROM items WHERE id = $id");
      }
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    assert vulnerabilities.any? { |v| v[:type] == "SQL Injection" }
    assert vulnerabilities.count >= 3
  end

  test "detects XSS vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Reflected XSS
      echo $_GET['name'];
      print $_GET['search'];
      ?>
      <div><?= $_GET['user'] ?></div>
      
      <?php
      // Stored XSS
      function render_comment() {
        $comment = get_comment();
        echo $comment['text'];
      }
      
      // Shortcode XSS
      add_shortcode('user_profile', function($atts) {
        return '<div>' . $atts['name'] . '</div>';
      });
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    xss_vulns = vulnerabilities.select { |v| v[:type].include?("XSS") }
    assert xss_vulns.count >= 4
  end

  test "detects remote code execution vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Direct eval
      eval($_POST['code']);
      
      // System commands
      system($_GET['cmd']);
      exec($_REQUEST['command']);
      
      // Dynamic function calls
      $func = $_GET['function'];
      $func($_GET['param']);
      
      // call_user_func
      call_user_func($_POST['callback'], $_POST['data']);
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    rce_vulns = vulnerabilities.select { |v| v[:type] == "Remote Code Execution" }
    assert rce_vulns.count >= 5
    assert rce_vulns.all? { |v| v[:severity] == "critical" }
  end

  test "detects file upload vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Missing file type check
      move_uploaded_file($_FILES['upload']['tmp_name'], '/uploads/' . $_FILES['upload']['name']);
      
      // Allowing .htaccess upload
      if ($_FILES['file']['name'] == '.htaccess') {
        move_uploaded_file($_FILES['file']['tmp_name'], '/public/.htaccess');
      }
      
      // Weak extension check
      $ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);
      if ($ext != 'php') {
        move_uploaded_file($_FILES['file']['tmp_name'], '/uploads/' . $_FILES['file']['name']);
      }
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    upload_vulns = vulnerabilities.select { |v| v[:type] == "Arbitrary File Upload" }
    assert upload_vulns.count >= 3
  end

  test "detects access control vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Missing capability check
      add_action('wp_ajax_delete_user', function() {
        $user_id = $_POST['user_id'];
        wp_delete_user($user_id);
      });
      
      // Public AJAX endpoint with sensitive operation
      add_action('wp_ajax_nopriv_update_settings', function() {
        update_option('site_settings', $_POST['settings']);
      });
      
      // REST route without permission callback
      register_rest_route('myplugin/v1', '/users/delete', array(
        'methods' => 'POST',
        'callback' => 'delete_user_handler'
      ));
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    access_vulns = vulnerabilities.select { |v| v[:type] == "Broken Access Control" }
    assert access_vulns.count >= 3
  end

  test "detects CSRF vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Missing nonce verification
      add_action('admin_post_save_settings', function() {
        if (isset($_POST['settings'])) {
          update_option('my_settings', $_POST['settings']);
        }
      });
      
      // State-changing GET request
      if ($_GET['action'] == 'delete') {
        delete_option($_GET['option']);
      }
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    csrf_vulns = vulnerabilities.select { |v| v[:type] == "CSRF" }
    assert csrf_vulns.count >= 2
  end

  test "detects privilege escalation vulnerabilities" do
    vulnerable_code = <<~PHP
      <?php
      // Arbitrary option update
      update_option($_POST['option_name'], $_POST['option_value']);
      
      // User capability manipulation
      $user_id = get_current_user_id();
      update_user_meta($user_id, 'wp_capabilities', $_POST['capabilities']);
      
      // Role parameter tampering
      wp_insert_user(array(
        'user_login' => $_POST['username'],
        'user_pass' => $_POST['password'],
        'role' => $_POST['role']
      ));
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, vulnerable_code, "test.php")
    
    priv_esc_vulns = vulnerabilities.select { |v| v[:type] == "Privilege Escalation" }
    assert priv_esc_vulns.count >= 3
    assert priv_esc_vulns.all? { |v| v[:severity] == "critical" }
  end

  test "identifies WordPress context correctly" do
    code_with_context = <<~PHP
      <?php
      // AJAX endpoint
      add_action('wp_ajax_my_action', 'my_handler');
      add_action('wp_ajax_nopriv_public_action', 'public_handler');
      
      // REST route
      register_rest_route('myplugin/v1', '/data', array(
        'methods' => 'GET',
        'callback' => 'get_data'
      ));
      
      // Shortcode
      add_shortcode('myshortcode', 'render_shortcode');
      
      // Gutenberg block
      register_block_type('myplugin/myblock', array(
        'render_callback' => 'render_block'
      ));
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    # This would need access to the scanner's context tracking
    # Assert that context is properly identified
  end

  test "avoids false positives with proper escaping" do
    safe_code = <<~PHP
      <?php
      // Properly escaped output
      echo esc_html($_GET['name']);
      echo esc_attr($_POST['title']);
      echo esc_url($_GET['redirect']);
      
      // Prepared SQL queries
      global $wpdb;
      $results = $wpdb->get_results(
        $wpdb->prepare("SELECT * FROM table WHERE id = %d", $_GET['id'])
      );
      
      // Nonce verification
      if (isset($_POST['submit']) && wp_verify_nonce($_POST['_wpnonce'], 'my_action')) {
        update_option('my_option', sanitize_text_field($_POST['value']));
      }
      
      // Capability check
      if (current_user_can('manage_options')) {
        delete_option($_POST['option']);
      }
    PHP

    scanner = VulnerabilityScanner.new(@scan)
    vulnerabilities = scan_content(scanner, safe_code, "test.php")
    
    # Should have minimal or no vulnerabilities
    assert vulnerabilities.count == 0, "Safe code should not trigger vulnerabilities"
  end

  private

  def scan_content(scanner, content, filename)
    # This is a simplified version - in reality, the scanner works with files
    vulnerabilities = []
    
    scanner.instance_eval do
      @vulnerabilities_found = []
      scan_with_pattern(content, pattern, vuln_type, config, filename)
      @vulnerabilities_found
    end
    
    vulnerabilities
  end
end
